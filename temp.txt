package main

import (
	"encoding/json"

	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2"
	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/redshift"
	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/s3"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		// @fixme - not sure what the unique id is used for.
		pGeneratedUniqueId := "tempid"

		pNotificationList := "temp@hool.co"

		pVpcId := "vpc-0c1f4105aea0108b6"
		// pDbAvailabilityZones := []string{
		// 	"us-east-1a",
		// 	"us-east-1b",
		// }
		pDbSubnetIds := []string{
			"subnet-0d0f0bca649e2ca05",
			"subnet-0de5edd7b1c3410a3",
		}

		// "ID of the security group (e.g., sg-0234se). One will be created for you if left empty."
		// var pCustomSecurityGroupId *string = nil

		pDbPort := 5432
		pDatabaseName := "tempdbname"

		pDbAccessCidr := "0.0.0.0/0"

		//@fixme - replace these fields with secret inputs
		pDbMasterUsername := "tempuser"
		pDbMasterUserPassword := "Temp-master-password-vnoxzghoahrtwfnoaovnasf12!"

		// @todo - can these be converted into a struct?
		pTagEnvironment := "dev"
		pTagProjectCostCenter := "dev"
		pTagConfidentiality := "none"
		pTagCompliance := "none"

		// "ID of the security group (e.g., sg-0234se). One will be created for you if left empty."
		// var pCustomSecurityGroupId *string = nil

		pPubliclyAccessible := true

		pMaxConcurrentCluster := "1"

		/**
		 * Redshift security group
		 */
		dbSecurityGroup, dbSecurityGroupErr := ec2.NewSecurityGroup(ctx, "allowTls", &ec2.SecurityGroupArgs{
			Description: pulumi.String("Allow TLS inbound traffic to database port"),
			VpcId:       pulumi.String(pVpcId),
			Ingress: ec2.SecurityGroupIngressArray{
				&ec2.SecurityGroupIngressArgs{
					Description: pulumi.String("TLS DB port for db access cidr"),
					FromPort:    pulumi.Int(pDbPort),
					ToPort:      pulumi.Int(pDbPort),
					Protocol:    pulumi.String("tcp"),
					CidrBlocks: pulumi.StringArray{
						pulumi.String(pDbAccessCidr),
					},
				},
			},
			Tags: pulumi.StringMap{
				"Name":              pulumi.String("allow_db_access"),
				"Environment":       pulumi.String(pTagEnvironment),
				"ProjectCostCenter": pulumi.String(pTagProjectCostCenter),
				"Confidentiality":   pulumi.String(pTagConfidentiality),
				"Compliance":        pulumi.String(pTagCompliance),
			},
		})

		if dbSecurityGroupErr != nil {
			return dbSecurityGroupErr
		}

		redshiftClusterParameterGroup, redshiftClusterParameterGroupErr := redshift.NewParameterGroup(ctx, "cluster-paramter-group", &redshift.ParameterGroupArgs{
			Description: pulumi.String("Redshift-Cluster-Parameter-Group-" + pGeneratedUniqueId),
			Family:      pulumi.String("redshift-1.0"),
			Parameters: redshift.ParameterGroupParameterArray{
				redshift.ParameterGroupParameterArgs{
					Name:  pulumi.String("enable_user_activity_logging"),
					Value: pulumi.String("false"),
				},
				redshift.ParameterGroupParameterArgs{
					Name:  pulumi.String("require_ssl"),
					Value: pulumi.String("true"),
				},
				redshift.ParameterGroupParameterArgs{
					Name:  pulumi.String("auto_analyze"),
					Value: pulumi.String("true"),
				},
				redshift.ParameterGroupParameterArgs{
					Name:  pulumi.String("statement_timeout"),
					Value: pulumi.String("43200000"),
				},
				redshift.ParameterGroupParameterArgs{
					Name:  pulumi.String("max_concurrency_scaling_clusters"),
					Value: pulumi.String(pMaxConcurrentCluster),
				},
				// redshift.ParameterGroupParameterArgs{
				// 	Name:  pulumi.String("wlm_json_configuration"),
				// 	Value: pulumi.String("43200000"),
				// @fixme - !Sub '[ { "query_group" : [ ],"query_group_wild_card" : 0,"user_group" : [ ],"user_group_wild_card" : 0,"concurrency_scaling" : "${ConcurrencyScaling}","rules" : [ {  "rule_name" : "DiskSpilling",  "predicate" : [ { "metric_name" : "query_temp_blocks_to_disk", "operator" : ">", "value" : 100000  } ], "action" : "log"}, {  "rule_name" : "RowJoining",  "predicate" : [ { "metric_name" : "join_row_count", "operator" : ">", "value" : 1000000000 } ],  "action" : "log"} ],"priority" : "normal","queue_type" : "auto","auto_wlm" : true }, {"short_query_queue" : true } ]'
				// },
			},
		})

		if redshiftClusterParameterGroupErr != nil {
			return redshiftClusterParameterGroupErr
		}

		redshiftClusterSubnetGroup, redshiftClusterSubnetGroupErr := redshift.NewSubnetGroup(ctx, "redshift-cluster-subnet-group", &redshift.SubnetGroupArgs{
			Description: pulumi.String("Cluster subnet group"),
			SubnetIds:   pulumi.ToStringArray(pDbSubnetIds),
			Name:        pulumi.String("primary-redshift-subnet-group"),
			Tags: pulumi.StringMap{
				"Environment":       pulumi.String(pTagEnvironment),
				"ProjectCostCenter": pulumi.String(pTagProjectCostCenter),
				"Confidentiality":   pulumi.String(pTagConfidentiality),
				"Compliance":        pulumi.String(pTagCompliance),
			},
		})

		if redshiftClusterSubnetGroupErr != nil {
			return redshiftClusterSubnetGroupErr
		}

		// glueCatalogDb, glueCatalogDbErr := glue.NewCatalogDatabase(ctx, "glue-catalog", &glue.CatalogDatabaseArgs{
		// 	CatalogId: ctx.,
		// 	TargetDatabase: glue.CatalogDatabaseTargetDatabaseArgs{
		// 		CatalogId: pulumi.String("temp"),
		// 		DatabaseName: ,
		// 	}
		// })

		redshiftLoggingS3Bucket, redshiftLoggingBucketErr := s3.NewBucket(ctx, "redshift-logging-bucket", &s3.BucketArgs{
			// LifecycleRules: ,
			Tags: pulumi.StringMap{
				"Name":              pulumi.String("allow_db_access"),
				"Environment":       pulumi.String(pTagEnvironment),
				"ProjectCostCenter": pulumi.String(pTagProjectCostCenter),
				"Confidentiality":   pulumi.String(pTagConfidentiality),
				"Compliance":        pulumi.String(pTagCompliance),
			},
		})

		if redshiftLoggingBucketErr != nil {
			return redshiftLoggingBucketErr
		}

		jsonBucketPolicy, jsonBucketPolicyErr := json.Marshal(
			(map[string]interface{}{
				"Version": "2012-10-17",
				"Id":      "MYBUCKETPOLICY",
				"Statement": []map[string]interface{}{
					map[string]interface{}{
						"Sid":    "IPAllow",
						"Effect": "Allow",
						"Principal": map[string]interface{}{
							"AWS": "arn:aws:iam::" + "@fixme" + ":user/logs",
						},
						"Action":   "s3:GetBucketAcl",
						"Resource": redshiftLoggingS3Bucket.Arn,
					},
					map[string]interface{}{
						"Sid":    "IPAllow",
						"Effect": "Allow",
						"Principal": map[string]interface{}{
							"AWS": "arn:aws:iam::" + "@fixme" + ":user/logs",
						},
						"Action":   "s3:PutObject",
						"Resource": "*",
						// @fixme - string interpolation
						// "Resource": redshiftLoggingS3Bucket.Arn + "/AWSLogs/*",
					},
				},
			}),
		)

		if jsonBucketPolicyErr != nil {
			return jsonBucketPolicyErr
		}

		_, redshiftLoggingS3BucketPolicyErr := s3.NewBucketPolicy(ctx, "logging-bucket-policy", &s3.BucketPolicyArgs{
			Bucket: redshiftLoggingS3Bucket.ID(),
			Policy: pulumi.String(string(jsonBucketPolicy)),
		})

		if redshiftLoggingS3BucketPolicyErr != nil {
			return redshiftLoggingS3BucketPolicyErr
		}

		return nil
	})
}
